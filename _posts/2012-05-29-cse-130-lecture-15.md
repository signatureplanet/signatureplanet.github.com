---
layout: post
title: "CSE 130 Lecture 15"
description: ""
category: 
tags: [lecture]
---
{% include JB/setup %}

## Intro to PA6

   * Decorator as profile
   * ScalaCheck as Bst
	
object bob {def apply(x: Int} = x => x

## Case class

new can be skipped.

{% highlight scala %}
sealed class IntList
case class ICons(h: Int, t: IntLost) extends IntList
case class Nil()		     extends IntList

val l1 = new INil()  //is the same as
val l1 = INil()
{% endhighlight %}

## Subtyping

structual subtype 

{% highlight scala %}
{def next(): Any
 def hasNext: Boolean }
{% endhighlight %}

A type is a contract

{% highlight scala %}
def screenSaver(p: Point) {
  // Only uses properties described in Point
}
{% endhighlight %}

Contract between screenSaver and its Caller.
Callser promises to only send Point values.

What is the Point?

   * any object with Point attributes.
   * if object has more attributes, no problem.
	* This is called subtyping

{% highlight scala %}
S <: T  //S is a subtype of T
{% endhighlight %}

S is less than T if S is T.

S has more attribute than T/

Width Subtyping


Depth subtyping:
{% highlight scala %}
class Line
{
  val p1: Dot
  val p2: Dot
}
class colorLine
{
  val p1: ColorDot
  val p2: ColorDot
}
{% endhighlight %}

Function subtyping

1. The same input type

If S <: T then In => S <: In => T

2. The same output type

If S <: T then T => Out <: S => Out


{% highlight scala %}
plotGraphic(x: Dot => Graphics)
{% endcolor %}

We cannot pass cd2g: ColorDot => Graphics to plotGraphics because gd2g could use properties that only the ColorDot has.




## Google it

* Propertie class
